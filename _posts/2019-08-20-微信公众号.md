## **1、微信公众号开发**

![微信公众号接入](https://raw.githubusercontent.com/Panssorcc/picee/master/images/node-%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7-%E6%8E%A5%E5%85%A5_2019-09-16_11-13-20.png)

![验证公众号](https://raw.githubusercontent.com/Panssorcc/picee/master/images/node-%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7-%E9%AA%8C%E8%AF%81_2019-09-16_11-13-20.png)

### **安装`ngrok`**（内网穿透）

[官网](https://ngrok.com/download)

1. 下载ngrok客户端

2. 本地启动服务器，如http://localhost:8888，端口号为8888

3. 打开ngrok客户端，输入ngrok http 8888，启动内网穿透

4. 复制生成后的网址

5. ![配置](https://raw.githubusercontent.com/Panssorcc/picee/master/images/node-%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7-%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF_2019-09-16_11-13-20.png)

   ![启动内网穿透](https://raw.githubusercontent.com/Panssorcc/picee/master/images/node-%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7-ngrok%E5%90%AF%E5%8A%A8_2019-09-16_11-13-20.png)

### 验证服务器地址的有效性

   + `app.js`部分：

   1）将token、timestamp、nonce三个参数进行字典序排序 
   2）将三个参数字符串拼接成一个字符串进行sha1加密 
   3）开发者获得加密后的字符串可与signature对比，标识该请求来源于微信

```javascript
var express=require('express');
var sha1=require('sha1');
const app =express();

const config = {
    wechat: {
      appId: 'XXXXXXXXX',
      appsecret: '*****************************************',
      token: '####'
    }
  }
app.use((req,res,next)=>{

    // console.log(req.query)

    /* { signature: '3e3a5902b88be509d5d3e53e0b4a708b2399afc6' ,
    //微信的加密签名，结合你的token，timestamp和nonce经过某种算法生成的
  echostr: '6111278129223827167',//随机字符串，微信后台随机生成的
  timestamp: '1568618714',//时间戳，对应当前时间
  nonce: '1060563586' }//随机数，微信后台随机生成的 */

  const token = config.wechat.token

  const signature = req.query.signature
  const nonce = req.query.nonce
  const timestamp = req.query.timestamp
  const echostr = req.query.echostr


//1）将token、timestamp、nonce三个参数进行字典序排序 
//2）将三个参数字符串拼接成一个字符串进行sha1加密 
//3）开发者获得加密后的字符串可与signature对比，标识该请求来源于微信
  const str = [token, timestamp, nonce].sort().join('');

  const sha = sha1(str)

  if (sha === signature) {
    res.send(echostr)
  } else {
    res.send('wrong')
  }

});

app.listen(8888,()=>console.log('服务器启动成功'))
```





## 模态化

## **2、获取access_token**

access_token是公众号的全局唯一接口调用凭据，公众号调用各接口时都需使用access_token。开发者需要进行妥善保存。

### **2.1 目录结构**

├─ config/           	# 配置目录

​	    ├─ `index.js `		# 存储配置信息

├── wechat/          # 核心功能库

​		 ├─ `accessToken.txt ` # 存储access_token

​		 ├─` auth.js`		    # 验证服务器功能

​		 ├─ `wechat.js`		# 类wechat

├──index.js      	# 入口启动文件

├── `package.json `    	# 配置文件

### 2.2 配置模块

+ `config/index.js`文件

```javascript
/*
  此模块用来储存关键的配置信息
 */
module.exports = {
  appID: 'wxc8e92f7ab70fbca0',
  appsecret: 'b4054e90b75787c78e0af50bf7fc3e87',
  token: 'atguiguHTML1208'  //token要严格保密！！！
}


```
### 2.3 验证模块
+ ` wechat/auth.js`

  ```javascript
  
  const config = require('../config');
  //引入sha1加密模块
  const sha1 = require('sha1');
  
  module.exports = () => {
    
    return (req, res, next) => {
      //接受微信服务器发送过来的请求参数
      console.log(req.query);
      /*
        { signature: 'c4409bdd012bf28d8b4aabf7ac5847c5560d6cf0',   微信的加密签名（timestamp、nonce、token）
          echostr: '11283286178012191741',  随机字符串
          timestamp: '1529977721',          时间戳
          nonce: '1462949582' }             随机数字
       */
      //获取参与加密的参数
      const {signature, echostr, timestamp, nonce} = req.query;
      const {token} = config;
      /*// - 将timestamp、nonce、token三个参数按照字典序排序
      const arr = [timestamp, nonce, token].sort();
      // - 将三个参数拼接在一起，进行sha1加密
      const str = arr.join('');
      const sha1Str = sha1(str);*/
      //简写方式
      const sha1Str = sha1([timestamp, nonce, token].sort().join(''));
      // - 将加密后生成字符串和微信签名进行对比，
      if (sha1Str === signature) {
        //说明成功，返回echostr给微信服务器
        res.send(echostr);
      } else {
        //说明失败
        res.send('');
      }
    }
  }
  ```

  

### 2.4 获取**access_token**模块

#### 特点

 全局唯一的接口调用凭据，今后使用微信的接口基本上都需要携带上这个参数
 2小时需要更新一次，提前5分钟刷新

+  请求地址：https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=APPID&secret=APPSECRET

+  请求方式：GET

+ 发送**http**请求的库`request-promise-native`和`request`

  `npm install request request-promise-native `

#### 思路

>  先去本地查看有没有指定文件（`readAccessToken`）
>       	if（  如果有（之前请求过凭据））{
>
> ​      	   	if(   如果没有过期  ){					//判断凭据是否过期(`isValidAccessToken`)
>
> ​						直接使用
>
> ​			} else {//   如果过期了
>
> ​					重新发送请求获取凭据，保存下来覆盖之前的文件(`getAccessToken、saveAccessToken`)
>
> ​			}       	     
> ​        	   
>
> ​        }else if(	如果没有（之前都没有请求过凭据）){      
>
> ​				 发送请求获取凭据 `getAccessToken ()`，保存为一个唯一的文件
>
> }




```javascript

//引入配置对象
const {appID, appsecret} = require('../config');
//引入发送http请求的库
const rp = require('request-promise-native');
//引入fs模块
const {readFile, writeFile} = require('fs');

class Wechat {
  
  getAccessToken () {
    //定义请求地址
    const url = `https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=${appID}&secret=${appsecret}`;
    /*
      问题：需要将回调函数中的数据返回出去？
      解决：用promise解决
      
      所有的异步操作，都应该包装一层promise，让这个异步操作执行完毕之后，再去执行后面的代码
      简化： 所有的异步操作，都应该包装一层promise
     */
    return new Promise((resolve, reject) => {
      //发送http请求
      //下载 request-promise-native  request
      rp({method: 'GET', json: true, url})
        .then(res => {
          //请求成功的状态
          // console.log(res);
          //重新赋值凭据的过期时间 ： 当前时间 + (7200 - 5分钟) * 1000
          res.expires_in = Date.now() + (res.expires_in - 300) * 1000;
          // console.log(res);
          resolve(res);
        })
        .catch(err => {
          //请求失败
          reject('getAccessToken方法出了问题：' + err);
        })
    })
  }
  saveAccessToken (data) {
    /*
      问题：writeFile方法会将对象转化为字符串
      解决：我将对象转化为json字符串
     */
    data = JSON.stringify(data);
    return new Promise((resolve, reject) => {
      //将凭据保存为一个文件
      writeFile('accessToken.txt', data, err => {
        if (!err) {
          //写入成功
          resolve();
        } else {
          //写入失败
          reject('saveAccessToken方法出了问题：' + err);
        }
      })
    })
  }
  readAccessToken () {
    return new Promise((resolve, reject) => {
      //将凭据读取出来
      readFile('accessToken.txt', (err, data) => {
        if (!err) {
          //将读取的Buffer数据转化为json字符串
          data = data.toString();
          //将json字符串转化为对象
          data = JSON.parse(data);
          //读取成功
          resolve(data);
        } else {
          //读取失败
          reject('readAccessToken方法出了问题：' + err);
        }
      })
    })
  }
  isValidAccessToken (data) {
    /*
      判断凭据是否过期
        true   凭据没有过期
        false  凭据过期了
     */
    //过滤非法的数据
    if (!data || !data.access_token || !data.expires_in) return false;
    //判断凭据是否过期
    /*if (data.expires_in > Date.now()) {
      //如果凭据的过期时间大于当前时间，说明没有过期
      return true
    } else {
      //如果凭据的过期时间小于当前时间，说明过期了
      return false
    }*/
    //简写方式
    return data.expires_in > Date.now();
  }
  fetchAccessToken () {
    //优化操作,优化不去执行读取文件操作
    if (this.access_token && this.expires_in && this.isValidAccessToken(this)) {
      //说明this有凭据和过期时间，并且凭据未过期
      return Promise.resolve({access_token: this.access_token, expires_in: this.expires_in});
    }
    
    return this.readAccessToken()
      .then(async res => {
        //判断凭据是否过期(isValidAccessToken)
        if (this.isValidAccessToken(res)) {
          //没有过期，直接使用
          return Promise.resolve(res);
        } else {
          //重新发送请求获取凭据
          const data = await this.getAccessToken();
          //保存下来
          await this.saveAccessToken(data);
          //将请求回来的凭据返回出去
          return Promise.resolve(data);
        }
      })
      .catch(async err => {
        console.log(err);
        //重新发送请求获取凭据
        const data = await this.getAccessToken();
        //保存下来
        await this.saveAccessToken(data);
        //将请求回来的凭据返回出去
        return Promise.resolve(data);
      })
      .then(res => {
        //将其请求回来的凭据和过期时间挂载到this上
        this.access_token = res.access_token;
        this.expires_in = res.expires_in;
        //指定fetchAccessToken方法返回值
        return Promise.resolve(res);
      })
  }
}
```

#### 没有封装成函数前使用：

```javascript
var w = new Wechat();
var accessToken = new Promise((resolve, reject) => {
    w.readAccessToken()
        .then(res => {
            if (w.isValidAccessToken(res)) {
                //没有过期，直接使用
                resolve(data)
            } else {
                //重新发送请求获取凭据
                w.getAccessToken()
                    .then(data => {
                        //保存AccessToken
                        w.saveAccessToken(data).then(() => {
                            resolve(data)
                        })
                    })
            }
        })
        .catch(err => {
            //不存在，获取AccessToken
            w.getAccessToken()
                .then(data => {
                    //保存AccessToken
                    w.saveAccessToken(data).then(() => {
                        resolve(data)
                    })
                })
        })
})

accessToken.then(res => {
    console.log(res);
})
```

#### 封装后使用

```javascript
var w = new Wechat();
w.fetchAccessToken()
.then(res=>{
    console.log(res.access_token);
})
.catch(err=>{
    console.log("获取失败"+res);
})
```



## 3、自动回复模板

### 3.1 目录结构

目录结构
├─ config/           	# 配置目录
│   ├─ index.js 		# 存储配置信息
├─ libs/              	# 工具方法库
│   ├─ util.js		# 解析字符串的工具方法
├─reply
│   ├─ reply.js		# 处理用户发送的信息
│   ├─ template.js		# 返回给用户的信息模板
├── wechat/         	# 核心功能库
│   ├─ accessToken.txt	# accessToken存储
│   ├─ auth.js		# 回复消息功能
│   ├─ wechat.js		# 类Wechat
├── app.js         	# 入口启动文件
├── package.json     	# 配置文件

### 3.2 解析字符串的工具方法

+ `utils.js`（对req解析返回Promise对象）

  

  ```javascript
  /*
    工具函数
   */
  //引入解析xml数据的库
  const {parseString} = require('xml2js');
  module.exports = {
      getUserDataAsync(req) {
          return new Promise((resolve, reject) => {
              let xmlData = '';
              req
                  .on('data', data => {
                      //当流式数据传递过来时，会触发当前事件，会将数据注入到回调函数中
                      //   console.log(data.toString());
                      //读取的数据是buffer，需要将其转化成字符串
                      xmlData += data.toString();
                  })
                  .on('end', () => {
                      //当数据接受完毕时，会触发当前
                      resolve(xmlData);
                  })
          })
      },
      parseXMLAsync (xmlData) {
          return new Promise((resolve, reject) => {
            parseString(xmlData, {trim: true}, (err, data) => {
              if (!err) {
                //解析成功了
                resolve(data);
              } else {
                //解析失败了
                reject('parseXMLAsync方法出了问题：' + err);
              }
            })
          })
        },
        formatMessage (jsData) {
          const data = jsData.xml;
          //初始化一个空的对象
          let message = {};
          //判断数据是一个合法的数据
          if (typeof data === 'object') {
            //循环遍历对象中的所有数据
            for (let key in data) {
              //获取属性值
              let value = data[key];
              //过滤掉空的数据和空的数组
              if (Array.isArray(value) && value.length > 0) {
                //在新对象中添加属性和值
                message[key] = value[0];
              }
            }
          }
          //将格式化后的数据返回出去
          return message;
        }
  }
  ```

  + 


### 3.3 返回给用户的信息模板

+ `temptate.js`（传参options返回xml数据）

  ```javascript
  /*
    用来加工处理最终回复用户消息的模板（xml数据）暴露函数
   */
  module.exports = options => {
    
      let replyMessage = `<xml><ToUserName><![CDATA[${options.toUserName}]]></ToUserName>
            <FromUserName><![CDATA[${options.fromUserName}]]></FromUserName>
            <CreateTime>${options.createTime}</CreateTime>
            <MsgType><![CDATA[${options.MsgType}]]></MsgType>`;
      
      if (options.MsgType === 'text') {
        replyMessage += `<Content><![CDATA[${options.content}]]></Content>`;
      } else if (options.MsgType === 'image') {
        replyMessage += `<Image><MediaId><![CDATA[${options.mediaId}]]></MediaId></Image>`;
      } else if (options.MsgType === 'voice') {//语音消息
        replyMessage += `<MediaId><![CDATA[${options.mediaId}]]></MediaId><Format><![CDATA[${options.Format}]]></Format><Recognition><![${options.Recognition}]]></Recognition>`;
      } else if (options.MsgType === 'video') {//视频消息
        replyMessage += `<Video>
          <MediaId><![CDATA[${options.mediaId}]]></MediaId>
          <Title><![CDATA[${options.title}]]></Title>
          <Description><![CDATA[${options.description}]]></Description>
          </Video>`;
      } else if (options.MsgType === 'music') {
        replyMessage += `<Music>
          <Title><![CDATA[${options.title}]]></Title>
          <Description><![CDATA[${options.description}]]></Description>
          <MusicUrl><![CDATA[${options.musicUrl}]]></MusicUrl>
          <HQMusicUrl><![CDATA[${options.hqMusicUrl}]]></HQMusicUrl>
          <ThumbMediaId><![CDATA[${options.mediaId}]]></ThumbMediaId>
          </Music>`;
      } else if (options.MsgType === 'news') {//图文
        replyMessage += `<ArticleCount>${options.content.length}</ArticleCount>
          <Articles>`;
      
        options.content.forEach(item => {
          replyMessage += `<item><Title><![CDATA[${item.title}]]></Title>
            <Description><![CDATA[${item.description}]]></Description>
            <PicUrl><![CDATA[${item.picUrl}]]></PicUrl>
            <Url><![CDATA[${item.url}]]></Url>
            </item>`
        })
      
        replyMessage += `</Articles>`;
      }else if(options.MsgType === 'location'){
          replyMessage +=`<Location_X>${options.locationX}</Location_X><Location_Y>${options.locationY}</Location_Y>
          <Scale>${options.size}</Scale>
          <Label><![CDATA[${options.locationContent}]]></Label>`
      }else if(options.MsgType === 'event'){//关注/取消关注事件
          if(options.Event==="subscribe"){
              replyMessage +=`<Content><![CDATA[${options.content}]]></Content>`;
          }
         
      }
      
      replyMessage += `<MsgId>${options.MsgId}</MsgId></xml>`;
      //最终回复给用户的xml数据
      return replyMessage;
    }
  ```

### 3.4  处理用户发送的信息

+ `reply.js`（根据解析后的对象message，返回options）

  ```javascript
  /* 
  *39p,处理并分析用户发送的消息
    决定返回什么消息给用户
  */
  module.exports=(message)=>{
      let options = {
          toUserName: message.FromUserName,
          fromUserName: message.ToUserName,
          createTime: Date.now(),
          MsgType: 'text',
          MsgId: message.MsgId
        }
  
        //设置回复用户消息的具体内容
        let content = '';
        //判断用户发送消息的类型和内容，决定返回什么消息给用户
        if (message.MsgType === 'text') {
          if (message.Content === '1') {
            content = '12345，上山打老虎';
          } else if (message.Content === '2') {
            content = '快来快来数一数 24678';
          } else if (message.Content === '博客'||message.Content === 'Blog'||message.Content === 'blog') {
            //回复图文消息
            content = [{
              title: 'Pcc Blog',
              description: '我的个人的博客',
              picUrl: 'https://raw.githubusercontent.com/Panssorcc/picee/master/blog/home_bg_pcc.jpg',
              url: 'https://panssorcc.github.io'
            }];
            options.MsgType = 'news';
  
          } else if (message.Content === 'map'||message.Content === '地图'||message.Content === '数据') {
            //回复图文消息
            content = [{
              title: 'Echarts',
              description: '用Echarts统计各地数据分布情况',
              picUrl: 'https://raw.githubusercontent.com/Panssorcc/picee/master/images/map_2019-09-16_11-13-20.png',
              url: 'http://203.195.242.11/project/mystudy/map/mapDistributed.html'
            }];
            options.MsgType = 'news';
  
          }
          else {
            content = '我不懂您说的话呢，例如：回复：博客，map等！试试看哟~';
          }
          options.content=content;
      
      }else  if(message.MsgType === 'voice'){//语音模板处理
          options.MsgType = message.MsgType;
          options.mediaId = message.MediaId;
          options.Format = message.Format;
          options.Recognition = message.Recognition;
         
        
      }else  if(message.MsgType === 'event'){//关注回复
          options.event = message.MsgType;
          content = 'Hello，欢迎关注麽思orcc的测试公众号哟~';
          options.content=content;
        
      } 
      return options;
  }
  
  ```

  

### 3.5 回复消息功能

- `auth.js`(调用解析函数和调用模板对象)

  ```javascript
  var sha1 = require('sha1');
  var config = require('../config');
  var { getUserDataAsync, parseXMLAsync, formatMessage } = require('../libs/utils');
  var temptate = require('../reply/template');
  var reply = require('../reply/reply');
  module.exports = () => {
  
    return async (req, res, next) => {
      const { signature, echostr, timestamp, nonce } = req.query;
      const { token } = config.wechat;
  
      const str = [token, timestamp, nonce].sort().join('');
      //   console.log(str);
      const sha = sha1(str)
      if (req.method === "GET") {
        if (sha === signature) {
          console.log("验证成功");
          res.send(echostr)
        } else {
          console.log("验证shibei");
          res.send('wrong')
        }
      } else if (req.method === "POST") {
        if (sha !== signature) {
          res.send('error');
          return
        }
       
  
        const xmlData = await getUserDataAsync(req);
        // console.log(xmlData);
        /* <xml>
        <ToUserName><![CDATA[gh_5f2e8b06a468]]></ToUserName>
        <FromUserName><![CDATA[oPuyU5_hhQOF1w2ArGjspdmnAMCQ]]></FromUserName>
        <CreateTime>1568779216</CreateTime>
        <MsgType><![CDATA[text]]></MsgType>
        <Content><![CDATA[3]]></Content>
        <MsgId>22459521748601090</MsgId>
        </xml> */
        const jsData = await parseXMLAsync(xmlData);
      
        const message = await formatMessage(jsData);
        console.log(message);
        /* 
      
      { ToUserName: 'gh_5f2e8b06a468',
        FromUserName: 'oPuyU5_hhQOF1w2ArGjspdmnAMCQ',
        CreateTime: '1568780891',
        MsgType: 'text',
        Content: '4',
        MsgId: '22459539358494612' }
        
        */
        const options = reply(message);
        const replyMessage = temptate(options);
  
        console.log(replyMessage);
        // //返回响应给微信服务器
        res.send(replyMessage);
  
      }
  
    }
  }
  ```
  

## 4、实现自定义菜单
## 5、获取api_ticket（）

### **获取JSAPI_TICKET接口**

**接口调用请求说明**

```
http请求方式: GET 
https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=ACCESS_TOKEN&type=jsapi
```

**返回数据**

```json
{
    "errcode": 0,
    "errmsg": "ok",
    "ticket": "bxLdikRXVbTPdHSM05e5u5sUoXNKd8-41ZO3MhKoyN5OfkWITDGgnr2fwJ0m9E8NYzWKVZvdVtaUgWvsdshFKA",
    "expires_in": 7200
}
```

+ > **注意：http请求方式链接中的type=jsapi**（重要！！！）

```javascript

     /**
   * 用来保存jsapi_ticket
   * @param ticket 要保存的票据
   */
  
    getTicket() {
     
      return new Promise(async (resolve, reject) => {
        var access_token=await this.fetchAccessToken();
        const url = `${api.ticket}?access_token=${access_token.access_token}&type=jsapi`
          rp({ method: 'GET', json: true, url })
              .then(res => {
                 
                  //重新赋值票据的过期时间 ： 当前时间 + (7200 - 5分钟) * 1000
                  res.expires_in = Date.now() + (res.expires_in - 300) * 1000;
               
                  resolve(res)
              })
              .catch(err => {
                  console.log("获取getTicket错误！" + res);
                  reject("获取getTicket错误！" + res)
              })
      })


  }

  saveTicket(data) {
      data = JSON.stringify(data);
      return new Promise((resolve, reject) => {
          fs.writeFile('ticket.txt', data, (err) => {
              if (!err) {
                  //写入成功
                  resolve();
              } else {
                  //写入失败
                  reject('saveTicket方法出了问题：' + err);
              }
          })
      })
  }

  readTicket() {
      return new Promise((resolve, reject) => {
          fs.readFile('ticket.txt', (err, data) => {
              if (!err) {
                  //写入成功
                  data = JSON.parse(data);
                  
                  resolve(data);
              } else {
                  //写入失败
                  reject('readticket方法出了问题：' + err);
              }
          })
      })

  }
  isValidTicket(data) {
      /*
    判断凭据是否过期
      true   凭据没有过期
      false  凭据过期了
   */
      if (!data || ! !data.ticket || !data.expires_in) return false;//过滤非法的数据

      /*   if (data.expires_in > Date.now()) {
            //如果凭据的过期时间大于当前时间，说明没有过期
            return true
          } else {
            //如果凭据的过期时间小于当前时间，说明过期了
            return false
          } */

      return data.expires_in > Date.now();

  }

  /**
   * 用来获取没有过期的ticket
   * @return {Promise<any>} ticket
   */
  fetchTicket () {
    //优化
    if (this.ticket && this.ticket_expires_in && this.isValidTicket(this)) {
      //说明之前保存过ticket，并且它是有效的, 直接使用
      return Promise.resolve({
        ticket: this.ticket,
        expires_in: this.ticket_expires_in
      })
    }
    
    return this.readTicket()
      .then(async res => {
        //本地有文件
        //判断它是否过期
        if (this.isValidTicket(res)) {
          //有效的
          return Promise.resolve(res);
        } else {
          //过期了
          const res = await this.getTicket();
          await this.saveTicket(res);
          return Promise.resolve(res);
        }
      })
      .catch(async err => {
        //本地没有文件
        const res = await this.getTicket();
        await this.saveTicket(res);
        return Promise.resolve(res);
      })
      .then(res => {
        //将ticket挂载到this上
        this.ticket = res.ticket;
        this.ticket_expires_in = res.expires_in;
        //返回res包装了一层promise对象（此对象为成功的状态）
        return Promise.resolve(res);
      })
  }

   
```

## 6、后台 JSSDK使用接口签名

### 微信封装的后台 接口签名sign



```javascript
var createNonceStr = function () {
  return Math.random().toString(36).substr(2, 15);
};

var createTimestamp = function () {
  return parseInt(new Date().getTime() / 1000) + '';
};

var raw = function (args) {
  var keys = Object.keys(args);
  keys = keys.sort()
  var newArgs = {};
  keys.forEach(function (key) {
    newArgs[key.toLowerCase()] = args[key];
  });

  var string = '';
  for (var k in newArgs) {
    string += '&' + k + '=' + newArgs[k];
  }
  string = string.substr(1);
  return string;
};

/**
* @synopsis 签名算法 
*
* @param jsapi_ticket 用于签名的 jsapi_ticket
* @param url 用于签名的 url ，注意必须动态获取，不能 hardcode
*
* @returns
*/
var sign = function (jsapi_ticket, url) {
  var ret = {
    jsapi_ticket: jsapi_ticket,
    nonceStr: createNonceStr(),
    timestamp: createTimestamp(),
    url: url
  };
  var string = raw(ret);
      sha1 = require('sha1');
      shaObj = sha1(string);
  ret.signature = shaObj;

  return ret;
};

module.exports = sign;

```

+ 使用微信`sign.js `接口签名

  

  ```javascript
  var sign = require('./sign.js');
  
  console.log(sign('jsapi_ticket', 'http://example.com'));
  /*
   *something like this
   *{
   *  jsapi_ticket: 'jsapi_ticket',
   *  nonceStr: '82zklqj7ycoywrk',
   *  timestamp: '1415171822',
   *  url: 'http://example.com',
   *  signature: '1316ed92e0827786cfda3ae355f33760c4f70c1f'
   *}
   */
  ```

  + 具体实现：

```javascript
const express = require('express');
const auth = require('./wechat/auth');
const Wechat = require('./wechat/wechat');
const {url,appId} = require('./config').wechat;
const sha1 = require('sha1');
var sign = require('./sign/sign');


const app = express();

app.set('views', 'views');
app.set('view engine', 'ejs');

const wechatApi = new Wechat();

app.get('/search', async (req, res,next) => {
  //用户访问微信中的网页触发的路由
  /*
    验证的签名算法
      1. 参与签名的字段包括noncestr（随机字符串）, 有效的jsapi_ticket, timestamp（时间戳）, url（当前网页的URL，不包含#及其后面部分）
      2. 对所有待签名参数按照字段名的ASCII 码从小到大排序（字典序）后，
      3. 使用URL键值对的格式（即key1=value1&key2=value2…）拼接成字符串string1。这里需要注意的是所有参数名均为小写字符。
      4. 对string1作sha1加密，字段名和字段值都采用原始值，不进行URL 转义。
   */
  //获取ticket
  const {ticket} = await wechatApi.fetchTicket();

  sign=sign(ticket, url+'/search')
 
  console.log(sign)
  // appId=sign.appId
  signature=sign.signature
  noncestr=sign.nonceStr
  timestamp=sign.timestamp

  //将数据渲染到页面上
  res.render('movie', {
    appId,
    signature,
    noncestr,
    timestamp
  })
  
  // next();
  
}) 

//应用中间级，能够接受处理所有请求
app.use(auth());

app.listen(8888, err => {
  if (!err) console.log('服务器启动成功了~~~');
})
```

### 自己node的后台 接口签名

+   验证的签名算法

+ [**常见错误及解决方法**](https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html#66)
![invalid signature签名错误](https://raw.githubusercontent.com/Panssorcc/picee/master/images/node-%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7-invalid%20signature%E7%AD%BE%E5%90%8D%E9%94%99%E8%AF%AF_2019-09-16_11-13-20.png)

  > 1. 参与签名的字段包括noncestr（随机字符串）, 有效的jsapi_ticket, timestamp（时间戳）, url（当前网页的URL，不包含#及其后面部分）
  >
  > 2. 对所有待签名参数按照字段名的ASCII 码从小到大排序（字典序）后，
  >
  > 3. 使用URL键值对的格式（即key1=value1&key2=value2…）拼接成字符串string1。这里需要注意的是所有参数名均为小写字符。
  >
  > 4. 对string1作sha1加密，字段名和字段值都采用原始值，不进行URL 转义。
  >
  >       

```javascript
const express = require('express');
const auth = require('./wechat/auth');
const Wechat = require('./wechat/wechat');
const {appId} = require('./config').wechat;
const sha1 = require('sha1');
const app = express();

app.set('views', 'views');
app.set('view engine', 'ejs');

const wechatApi = new Wechat();

app.get('/search', async (req, res) => {
  var url=req.query.url1;
  console.log("前端encodeURIComponent："+url)
  url=decodeURIComponent(url)
  console.log("decodeURIComponent："+url)
  fal="";//标记ajax和ejs
  if(url=="undefined"){
  
    res.render('search',{
      fal:false
    })
  }else{
//用户访问微信中的网页触发的路由
  /*
    验证的签名算法
      1. 参与签名的字段包括noncestr（随机字符串）, 有效的jsapi_ticket, timestamp（时间戳）, url（当前网页的URL，不包含#及其后面部分）
      2. 对所有待签名参数按照字段名的ASCII 码从小到大排序（字典序）后，
      3. 使用URL键值对的格式（即key1=value1&key2=value2…）拼接成字符串string1。这里需要注意的是所有参数名均为小写字符。
      4. 对string1作sha1加密，字段名和字段值都采用原始值，不进行URL 转义。
   */
  //获取ticket
  const {ticket} = await wechatApi.fetchTicket();
  //获取随机字符串
  const noncestr = Math.random().toString().split('.')[1];
  //获取当前时间戳
  const timestamp = Date.now().toString().substr(0,10);
 
 

  //2. 按照key=value将其拼接在一起
  const params = [
    'jsapi_ticket=' + ticket,
    'noncestr=' + noncestr,
    'timestamp=' + timestamp,
    'url=' + url 
  ]

  // 3. 按照字典序排序，再使用'&'将四个参数拼接在一起
  const string = params.sort().join('&');

  // 4. sha1加密
  const signature = sha1(string);
  appid =appId;
 
  
  //将数据JSON发送到页面上
  var obj = {"result":{
      appid,
      signature,
      noncestr,
      timestamp
    }};
    res.json(obj);
  
   
  
  }
  
})

//应用中间级，能够接受处理所有请求
app.use(auth());

app.listen(8888, err => {
  if (!err) console.log('服务器启动成功了~~~');
})
```



## 7、前端页面JSSDK使用步骤

[JSSDK使用步骤](https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html)

### **6.1简介**

微信JS-SDK ( JavaScript Software Development Kit )是微信公众平台面向网页开发者提供的基于微信内的网页开发工具包。

### **6.2功能**

通过使用微信JS-SDK，网页开发者可借助微信高效地使用拍照、选图、语音、位置等手机系统的能力，同时可以直接使用微信分享、扫一扫、卡券、支付等微信特有的能力，为微信用户提供更优质的网页体验。

简单来说，使用JS-SDK我们可以引入外部网页。

```ejs
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport"
        content="width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no">
  <title>猜电影</title>
</head>
<body>
<h1>点击标题，开始录音翻译</h1>
<div id="director"></div>
<p id="title"></p>
<p id="year"></p>
<p id="poster"></p>
<!--用来实现功能的移动端库-->
<script src="http://zeptojs.com/zepto-docs.min.js"></script>
<!--需要调用JS接口，就必须引入此文件 -->
<script src="http://res.wx.qq.com/open/js/jweixin-1.2.0.js"></script>
<script>
  $(function () {
    //微信全局配置，注入配置信息
    wx.config({
      debug: false, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。
      appId: '<%= appid%>', // 必填，公众号的唯一标识
      timestamp: '<%= timestamp %>', // 必填，生成签名的时间戳
      nonceStr: '<%= noncestr %>', // 必填，生成签名的随机串
      signature: '<%= signature %>',// 必填，签名
      jsApiList: [
        'startRecord',
        'stopRecord',
        'onVoiceRecordEnd',
        'translateVoice',
        'onMenuShareTimeline',
        'onMenuShareAppMessage',
        'onMenuShareQQ',
        'onMenuShareWeibo',
        'onMenuShareQZone'
      ] // 必填，需要使用的JS接口列表，没填的JS接口不能使用
    })
    //config信息验证后会执行ready方法，所有微信接口都在ready函数中调用
    wx.ready(function(){
      //判断当前客户端版本是否支持指定JS接口，此处只举一个例子
      wx.checkJsApi({
        jsApiList: ['onVoiceRecordEnd'], // 需要检测的JS接口列表，所有JS接口列表见附录2,
        success: function(res) {
          // 以键值对的形式返回，可用的api值true，不可用为false
          // 如：{"checkResult":{"chooseImage":true},"errMsg":"checkJsApi:ok"}
          console.log(res)
        }
      })

      const isRecording = false

      $('h1').on('tap', function () {
        if (!isRecording) {
          isRecording = true
          //开始录音
          wx.startRecord({
            cancel: function () {
              window.alert('您取消了音频录制，需要打开此功能')
            }
          })
          return
        }
        isRecording = false
        //停止录音
        wx.stopRecord({
          success: function (res) {
            const localId = res.localId
            //识别音频并返回识别结果
            wx.translateVoice({
              localId: localId,
              isShowProgressTips: 1, // 默认为1，显示进度提示
              success: function (res) {
                //识别后的结果，文本字符串
                const result = res.translateResult
                //根据结果请求豆瓣电影查询API
                $.getJSON('https://api.douban.com/v2/movie/search?q=' + result + '&callback=?', function (data) {
                  console.log(data)
                  const subjects = data.subjects[0]
                  console.log(subjects)
                  //将请求后返回的结果内容显示到页面上去
                  $('#director').html(subjects.directors[0].name)
                  $('#title').html(subjects.title)
                  $('#year').html(subjects.year)
                  $('#poster').html('<img src="' + subjects.images.large + '" />')
                  //添加一个分享给朋友接口
                  wx.onMenuShareAppMessage({
                    title: subjects.title, // 分享标题
                    desc: '我搜出来了' + subjects.title, // 分享描述
                    link: 'http://079e92c1.ngrok.io/share', // 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致
                    imgUrl: subjects.images.large, // 分享图标
                    type: 'link', // 分享类型,music、video或link，不填默认为link
                    dataUrl: '', // 如果type是music或video，则要提供数据链接，默认为空
                    success: function () {
                      // 用户确认分享后执行的回调函数
                      alert('分享成功')
                    },
                    cancel: function () {
                      // 用户取消分享后执行的回调函数
                      alert('分享失败')
                    }
                  })
                })
                alert(res.translateResult); // 语音识别的结果
              }
            })
          }
        })
      })
    })
  })
</script>
</body>
</html>
```





