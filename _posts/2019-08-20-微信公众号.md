qiniu`**1、微信公众号开发**

![微信公众号接入](https://raw.githubusercontent.com/Panssorcc/picee/master/images/node-%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7-%E6%8E%A5%E5%85%A5_2019-09-16_11-13-20.png)

![验证公众号](https://raw.githubusercontent.com/Panssorcc/picee/master/images/node-%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7-%E9%AA%8C%E8%AF%81_2019-09-16_11-13-20.png)

### **安装`ngrok`**（内网穿透）

[官网](https://ngrok.com/download)

1. 下载ngrok客户端

2. 本地启动服务器，如http://localhost:8888，端口号为8888

3. 打开ngrok客户端，输入ngrok http 8888，启动内网穿透

4. 复制生成后的网址

5. ![配置](https://raw.githubusercontent.com/Panssorcc/picee/master/images/node-%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7-%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF_2019-09-16_11-13-20.png)

   ![启动内网穿透](https://raw.githubusercontent.com/Panssorcc/picee/master/images/node-%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7-ngrok%E5%90%AF%E5%8A%A8_2019-09-16_11-13-20.png)

### 验证服务器地址的有效性

   + `app.js`部分：

   1）将token、timestamp、nonce三个参数进行字典序排序 
   2）将三个参数字符串拼接成一个字符串进行sha1加密 
   3）开发者获得加密后的字符串可与signature对比，标识该请求来源于微信

```javascript
var express=require('express');
var sha1=require('sha1');
const app =express();

const config = {
    wechat: {
      appId: 'XXXXXXXXX',
      appsecret: '*****************************************',
      token: '####'
    }
  }
app.use((req,res,next)=>{

    // console.log(req.query)

    /* { signature: '3e3a5902b88be509d5d3e53e0b4a708b2399afc6' ,
    //微信的加密签名，结合你的token，timestamp和nonce经过某种算法生成的
  echostr: '6111278129223827167',//随机字符串，微信后台随机生成的
  timestamp: '1568618714',//时间戳，对应当前时间
  nonce: '1060563586' }//随机数，微信后台随机生成的 */

  const token = config.wechat.token

  const signature = req.query.signature
  const nonce = req.query.nonce
  const timestamp = req.query.timestamp
  const echostr = req.query.echostr


//1）将token、timestamp、nonce三个参数进行字典序排序 
//2）将三个参数字符串拼接成一个字符串进行sha1加密 
//3）开发者获得加密后的字符串可与signature对比，标识该请求来源于微信
  const str = [token, timestamp, nonce].sort().join('');

  const sha = sha1(str)

  if (sha === signature) {
    res.send(echostr)
  } else {
    res.send('wrong')
  }

});

app.listen(8888,()=>console.log('服务器启动成功'))
```





## 模态化

## **2、获取access_token**

access_token是公众号的全局唯一接口调用凭据，公众号调用各接口时都需使用access_token。开发者需要进行妥善保存。

### **2.1 目录结构**

├─ config/           	# 配置目录

​	    ├─ `index.js `		# 存储配置信息

├── wechat/          # 核心功能库

​		 ├─ `accessToken.txt ` # 存储access_token

​		 ├─` auth.js`		    # 验证服务器功能

​		 ├─ `wechat.js`		# 类wechat

├──index.js      	# 入口启动文件

├── `package.json `    	# 配置文件

### 2.2 配置模块

+ `config/index.js`文件

```javascript
/*
  此模块用来储存关键的配置信息
 */
module.exports = {
  appID: 'wxc8e92f7ab70fbca0',
  appsecret: 'b4054e90b75787c78e0af50bf7fc3e87',
  token: 'atguiguHTML1208'  //token要严格保密！！！
}


```
### 2.3 验证模块
+ ` wechat/auth.js`

  ```javascript
  
  const config = require('../config');
  //引入sha1加密模块
  const sha1 = require('sha1');
  
  module.exports = () => {
    
    return (req, res, next) => {
      //接受微信服务器发送过来的请求参数
      console.log(req.query);
      /*
        { signature: 'c4409bdd012bf28d8b4aabf7ac5847c5560d6cf0',   微信的加密签名（timestamp、nonce、token）
          echostr: '11283286178012191741',  随机字符串
          timestamp: '1529977721',          时间戳
          nonce: '1462949582' }             随机数字
       */
      //获取参与加密的参数
      const {signature, echostr, timestamp, nonce} = req.query;
      const {token} = config;
      /*// - 将timestamp、nonce、token三个参数按照字典序排序
      const arr = [timestamp, nonce, token].sort();
      // - 将三个参数拼接在一起，进行sha1加密
      const str = arr.join('');
      const sha1Str = sha1(str);*/
      //简写方式
      const sha1Str = sha1([timestamp, nonce, token].sort().join(''));
      // - 将加密后生成字符串和微信签名进行对比，
      if (sha1Str === signature) {
        //说明成功，返回echostr给微信服务器
        res.send(echostr);
      } else {
        //说明失败
        res.send('');
      }
    }
  }
  ```

  

### 2.4 获取**access_token**模块

#### 特点

 全局唯一的接口调用凭据，今后使用微信的接口基本上都需要携带上这个参数
 2小时需要更新一次，提前5分钟刷新

+  请求地址：https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=APPID&secret=APPSECRET

+  请求方式：GET

+ 发送**http**请求的库`request-promise-native`和`request`

  `npm install request request-promise-native `

#### 思路

>  先去本地查看有没有指定文件（`readAccessToken`）
>       	if（  如果有（之前请求过凭据））{
>
> ​      	   	if(   如果没有过期  ){					//判断凭据是否过期(`isValidAccessToken`)
>
> ​						直接使用
>
> ​			} else {//   如果过期了
>
> ​					重新发送请求获取凭据，保存下来覆盖之前的文件(`getAccessToken、saveAccessToken`)
>
> ​			}       	     
> ​        	   
>
> ​        }else if(	如果没有（之前都没有请求过凭据）){      
>
> ​				 发送请求获取凭据 `getAccessToken ()`，保存为一个唯一的文件
>
> }




```javascript

//引入配置对象
const {appID, appsecret} = require('../config');
//引入发送http请求的库
const rp = require('request-promise-native');
//引入fs模块
const {readFile, writeFile} = require('fs');

class Wechat {
  
  getAccessToken () {
    //定义请求地址
    const url = `https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=${appID}&secret=${appsecret}`;
    /*
      问题：需要将回调函数中的数据返回出去？
      解决：用promise解决
      
      所有的异步操作，都应该包装一层promise，让这个异步操作执行完毕之后，再去执行后面的代码
      简化： 所有的异步操作，都应该包装一层promise
     */
    return new Promise((resolve, reject) => {
      //发送http请求
      //下载 request-promise-native  request
      rp({method: 'GET', json: true, url})
        .then(res => {
          //请求成功的状态
          // console.log(res);
          //重新赋值凭据的过期时间 ： 当前时间 + (7200 - 5分钟) * 1000
          res.expires_in = Date.now() + (res.expires_in - 300) * 1000;
          // console.log(res);
          resolve(res);
        })
        .catch(err => {
          //请求失败
          reject('getAccessToken方法出了问题：' + err);
        })
    })
  }
  saveAccessToken (data) {
    /*
      问题：writeFile方法会将对象转化为字符串
      解决：我将对象转化为json字符串
     */
    data = JSON.stringify(data);
    return new Promise((resolve, reject) => {
      //将凭据保存为一个文件
      writeFile('accessToken.txt', data, err => {
        if (!err) {
          //写入成功
          resolve();
        } else {
          //写入失败
          reject('saveAccessToken方法出了问题：' + err);
        }
      })
    })
  }
  readAccessToken () {
    return new Promise((resolve, reject) => {
      //将凭据读取出来
      readFile('accessToken.txt', (err, data) => {
        if (!err) {
          //将读取的Buffer数据转化为json字符串
          data = data.toString();
          //将json字符串转化为对象
          data = JSON.parse(data);
          //读取成功
          resolve(data);
        } else {
          //读取失败
          reject('readAccessToken方法出了问题：' + err);
        }
      })
    })
  }
  isValidAccessToken (data) {
    /*
      判断凭据是否过期
        true   凭据没有过期
        false  凭据过期了
     */
    //过滤非法的数据
    if (!data || !data.access_token || !data.expires_in) return false;
    //判断凭据是否过期
    /*if (data.expires_in > Date.now()) {
      //如果凭据的过期时间大于当前时间，说明没有过期
      return true
    } else {
      //如果凭据的过期时间小于当前时间，说明过期了
      return false
    }*/
    //简写方式
    return data.expires_in > Date.now();
  }
  fetchAccessToken () {
    //优化操作,优化不去执行读取文件操作
    if (this.access_token && this.expires_in && this.isValidAccessToken(this)) {
      //说明this有凭据和过期时间，并且凭据未过期
      return Promise.resolve({access_token: this.access_token, expires_in: this.expires_in});
    }
    
    return this.readAccessToken()
      .then(async res => {
        //判断凭据是否过期(isValidAccessToken)
        if (this.isValidAccessToken(res)) {
          //没有过期，直接使用
          return Promise.resolve(res);
        } else {
          //重新发送请求获取凭据
          const data = await this.getAccessToken();
          //保存下来
          await this.saveAccessToken(data);
          //将请求回来的凭据返回出去
          return Promise.resolve(data);
        }
      })
      .catch(async err => {
        console.log(err);
        //重新发送请求获取凭据
        const data = await this.getAccessToken();
        //保存下来
        await this.saveAccessToken(data);
        //将请求回来的凭据返回出去
        return Promise.resolve(data);
      })
      .then(res => {
        //将其请求回来的凭据和过期时间挂载到this上
        this.access_token = res.access_token;
        this.expires_in = res.expires_in;
        //指定fetchAccessToken方法返回值
        return Promise.resolve(res);
      })
  }
}
```

#### 没有封装成函数前使用：

```javascript
var w = new Wechat();
var accessToken = new Promise((resolve, reject) => {
    w.readAccessToken()
        .then(res => {
            if (w.isValidAccessToken(res)) {
                //没有过期，直接使用
                resolve(data)
            } else {
                //重新发送请求获取凭据
                w.getAccessToken()
                    .then(data => {
                        //保存AccessToken
                        w.saveAccessToken(data).then(() => {
                            resolve(data)
                        })
                    })
            }
        })
        .catch(err => {
            //不存在，获取AccessToken
            w.getAccessToken()
                .then(data => {
                    //保存AccessToken
                    w.saveAccessToken(data).then(() => {
                        resolve(data)
                    })
                })
        })
})

accessToken.then(res => {
    console.log(res);
})
```

#### 封装后使用

```javascript
var w = new Wechat();
w.fetchAccessToken()
.then(res=>{
    console.log(res.access_token);
})
.catch(err=>{
    console.log("获取失败"+res);
})
```



## 3、自动回复模板

### 3.1 目录结构

目录结构
├─ config/           	# 配置目录
│   ├─ index.js 		# 存储配置信息
├─ libs/              	# 工具方法库
│   ├─ util.js		# 解析字符串的工具方法
├─reply
│   ├─ reply.js		# 处理用户发送的信息
│   ├─ template.js		# 返回给用户的信息模板
├── wechat/         	# 核心功能库
│   ├─ accessToken.txt	# accessToken存储
│   ├─ auth.js		# 回复消息功能
│   ├─ wechat.js		# 类Wechat
├── app.js         	# 入口启动文件
├── package.json     	# 配置文件

### 3.2 解析字符串的工具方法

+ `utils.js`（对req解析返回Promise对象）

  

  ```javascript
  /*
    工具函数
   */
  //引入解析xml数据的库
  const {parseString} = require('xml2js');
  module.exports = {
      getUserDataAsync(req) {
          return new Promise((resolve, reject) => {
              let xmlData = '';
              req
                  .on('data', data => {
                      //当流式数据传递过来时，会触发当前事件，会将数据注入到回调函数中
                      //   console.log(data.toString());
                      //读取的数据是buffer，需要将其转化成字符串
                      xmlData += data.toString();
                  })
                  .on('end', () => {
                      //当数据接受完毕时，会触发当前
                      resolve(xmlData);
                  })
          })
      },
      parseXMLAsync (xmlData) {
          return new Promise((resolve, reject) => {
            parseString(xmlData, {trim: true}, (err, data) => {
              if (!err) {
                //解析成功了
                resolve(data);
              } else {
                //解析失败了
                reject('parseXMLAsync方法出了问题：' + err);
              }
            })
          })
        },
        formatMessage (jsData) {
          const data = jsData.xml;
          //初始化一个空的对象
          let message = {};
          //判断数据是一个合法的数据
          if (typeof data === 'object') {
            //循环遍历对象中的所有数据
            for (let key in data) {
              //获取属性值
              let value = data[key];
              //过滤掉空的数据和空的数组
              if (Array.isArray(value) && value.length > 0) {
                //在新对象中添加属性和值
                message[key] = value[0];
              }
            }
          }
          //将格式化后的数据返回出去
          return message;
        }
  }
  ```

  + 


### 3.3 返回给用户的信息模板

+ `temptate.js`（传参options返回xml数据）

  ```javascript
  /*
    用来加工处理最终回复用户消息的模板（xml数据）暴露函数
   */
  module.exports = options => {
    
      let replyMessage = `<xml><ToUserName><![CDATA[${options.toUserName}]]></ToUserName>
            <FromUserName><![CDATA[${options.fromUserName}]]></FromUserName>
            <CreateTime>${options.createTime}</CreateTime>
            <MsgType><![CDATA[${options.MsgType}]]></MsgType>`;
      
      if (options.MsgType === 'text') {
        replyMessage += `<Content><![CDATA[${options.content}]]></Content>`;
      } else if (options.MsgType === 'image') {
        replyMessage += `<Image><MediaId><![CDATA[${options.mediaId}]]></MediaId></Image>`;
      } else if (options.MsgType === 'voice') {//语音消息
        replyMessage += `<MediaId><![CDATA[${options.mediaId}]]></MediaId><Format><![CDATA[${options.Format}]]></Format><Recognition><![${options.Recognition}]]></Recognition>`;
      } else if (options.MsgType === 'video') {//视频消息
        replyMessage += `<Video>
          <MediaId><![CDATA[${options.mediaId}]]></MediaId>
          <Title><![CDATA[${options.title}]]></Title>
          <Description><![CDATA[${options.description}]]></Description>
          </Video>`;
      } else if (options.MsgType === 'music') {
        replyMessage += `<Music>
          <Title><![CDATA[${options.title}]]></Title>
          <Description><![CDATA[${options.description}]]></Description>
          <MusicUrl><![CDATA[${options.musicUrl}]]></MusicUrl>
          <HQMusicUrl><![CDATA[${options.hqMusicUrl}]]></HQMusicUrl>
          <ThumbMediaId><![CDATA[${options.mediaId}]]></ThumbMediaId>
          </Music>`;
      } else if (options.MsgType === 'news') {//图文
        replyMessage += `<ArticleCount>${options.content.length}</ArticleCount>
          <Articles>`;
      
        options.content.forEach(item => {
          replyMessage += `<item><Title><![CDATA[${item.title}]]></Title>
            <Description><![CDATA[${item.description}]]></Description>
            <PicUrl><![CDATA[${item.picUrl}]]></PicUrl>
            <Url><![CDATA[${item.url}]]></Url>
            </item>`
        })
      
        replyMessage += `</Articles>`;
      }else if(options.MsgType === 'location'){
          replyMessage +=`<Location_X>${options.locationX}</Location_X><Location_Y>${options.locationY}</Location_Y>
          <Scale>${options.size}</Scale>
          <Label><![CDATA[${options.locationContent}]]></Label>`
      }else if(options.MsgType === 'event'){//关注/取消关注事件
          if(options.Event==="subscribe"){
              replyMessage +=`<Content><![CDATA[${options.content}]]></Content>`;
          }
         
      }
      
      replyMessage += `<MsgId>${options.MsgId}</MsgId></xml>`;
      //最终回复给用户的xml数据
      return replyMessage;
    }
  ```

### 3.4  处理用户发送的信息

+ `reply.js`（根据解析后的对象message，返回options）

  ```javascript
  /* 
  *39p,处理并分析用户发送的消息
    决定返回什么消息给用户
  */
  module.exports=(message)=>{
      let options = {
          toUserName: message.FromUserName,
          fromUserName: message.ToUserName,
          createTime: Date.now(),
          MsgType: 'text',
          MsgId: message.MsgId
        }
  
        //设置回复用户消息的具体内容
        let content = '';
        //判断用户发送消息的类型和内容，决定返回什么消息给用户
        if (message.MsgType === 'text') {
          if (message.Content === '1') {
            content = '12345，上山打老虎';
          } else if (message.Content === '2') {
            content = '快来快来数一数 24678';
          } else if (message.Content === '博客'||message.Content === 'Blog'||message.Content === 'blog') {
            //回复图文消息
            content = [{
              title: 'Pcc Blog',
              description: '我的个人的博客',
              picUrl: 'https://raw.githubusercontent.com/Panssorcc/picee/master/blog/home_bg_pcc.jpg',
              url: 'https://panssorcc.github.io'
            }];
            options.MsgType = 'news';
  
          } else if (message.Content === 'map'||message.Content === '地图'||message.Content === '数据') {
            //回复图文消息
            content = [{
              title: 'Echarts',
              description: '用Echarts统计各地数据分布情况',
              picUrl: 'https://raw.githubusercontent.com/Panssorcc/picee/master/images/map_2019-09-16_11-13-20.png',
              url: 'http://203.195.242.11/project/mystudy/map/mapDistributed.html'
            }];
            options.MsgType = 'news';
  
          }
          else {
            content = '我不懂您说的话呢，例如：回复：博客，map等！试试看哟~';
          }
          options.content=content;
      
      }else  if(message.MsgType === 'voice'){//语音模板处理
          options.MsgType = message.MsgType;
          options.mediaId = message.MediaId;
          options.Format = message.Format;
          options.Recognition = message.Recognition;
         
        
      }else  if(message.MsgType === 'event'){//关注回复
          options.event = message.MsgType;
          content = 'Hello，欢迎关注麽思orcc的测试公众号哟~';
          options.content=content;
        
      } 
      return options;
  }
  
  ```

  

### 3.5 回复消息功能

- `auth.js`(调用解析函数和调用模板对象)

  ```javascript
  var sha1 = require('sha1');
  var config = require('../config');
  var { getUserDataAsync, parseXMLAsync, formatMessage } = require('../libs/utils');
  var temptate = require('../reply/template');
  var reply = require('../reply/reply');
  module.exports = () => {
  
    return async (req, res, next) => {
      const { signature, echostr, timestamp, nonce } = req.query;
      const { token } = config.wechat;
  
      const str = [token, timestamp, nonce].sort().join('');
      //   console.log(str);
      const sha = sha1(str)
      if (req.method === "GET") {
        if (sha === signature) {
          console.log("验证成功");
          res.send(echostr)
        } else {
          console.log("验证shibei");
          res.send('wrong')
        }
      } else if (req.method === "POST") {
        if (sha !== signature) {
          res.send('error');
          return
        }
       
  
        const xmlData = await getUserDataAsync(req);
        // console.log(xmlData);
        /* <xml>
        <ToUserName><![CDATA[gh_5f2e8b06a468]]></ToUserName>
        <FromUserName><![CDATA[oPuyU5_hhQOF1w2ArGjspdmnAMCQ]]></FromUserName>
        <CreateTime>1568779216</CreateTime>
        <MsgType><![CDATA[text]]></MsgType>
        <Content><![CDATA[3]]></Content>
        <MsgId>22459521748601090</MsgId>
        </xml> */
        const jsData = await parseXMLAsync(xmlData);
      
        const message = await formatMessage(jsData);
        console.log(message);
        /* 
      
      { ToUserName: 'gh_5f2e8b06a468',
        FromUserName: 'oPuyU5_hhQOF1w2ArGjspdmnAMCQ',
        CreateTime: '1568780891',
        MsgType: 'text',
        Content: '4',
        MsgId: '22459539358494612' }
        
        */
        const options = reply(message);
        const replyMessage = temptate(options);
  
        console.log(replyMessage);
        // //返回响应给微信服务器
        res.send(replyMessage);
  
      }
  
    }
  }
  ```
  

## 4、实现自定义菜单
## 5、获取api_ticket（）

### **获取JSAPI_TICKET接口**

**接口调用请求说明**

```
http请求方式: GET 
https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=ACCESS_TOKEN&type=jsapi
```

**返回数据**

```json
{
    "errcode": 0,
    "errmsg": "ok",
    "ticket": "bxLdikRXVbTPdHSM05e5u5sUoXNKd8-41ZO3MhKoyN5OfkWITDGgnr2fwJ0m9E8NYzWKVZvdVtaUgWvsdshFKA",
    "expires_in": 7200
}
```

+ > **注意：http请求方式链接中的type=jsapi**（重要！！！）

```javascript

     /**
   * 用来保存jsapi_ticket
   * @param ticket 要保存的票据
   */
  
    getTicket() {
     
      return new Promise(async (resolve, reject) => {
        var access_token=await this.fetchAccessToken();
        const url = `${api.ticket}?access_token=${access_token.access_token}&type=jsapi`
          rp({ method: 'GET', json: true, url })
              .then(res => {
                 
                  //重新赋值票据的过期时间 ： 当前时间 + (7200 - 5分钟) * 1000
                  res.expires_in = Date.now() + (res.expires_in - 300) * 1000;
               
                  resolve(res)
              })
              .catch(err => {
                  console.log("获取getTicket错误！" + res);
                  reject("获取getTicket错误！" + res)
              })
      })


  }

  saveTicket(data) {
      data = JSON.stringify(data);
      return new Promise((resolve, reject) => {
          fs.writeFile('ticket.txt', data, (err) => {
              if (!err) {
                  //写入成功
                  resolve();
              } else {
                  //写入失败
                  reject('saveTicket方法出了问题：' + err);
              }
          })
      })
  }

  readTicket() {
      return new Promise((resolve, reject) => {
          fs.readFile('ticket.txt', (err, data) => {
              if (!err) {
                  //写入成功
                  data = JSON.parse(data);
                  
                  resolve(data);
              } else {
                  //写入失败
                  reject('readticket方法出了问题：' + err);
              }
          })
      })

  }
  isValidTicket(data) {
      /*
    判断凭据是否过期
      true   凭据没有过期
      false  凭据过期了
   */
      if (!data || ! !data.ticket || !data.expires_in) return false;//过滤非法的数据

      /*   if (data.expires_in > Date.now()) {
            //如果凭据的过期时间大于当前时间，说明没有过期
            return true
          } else {
            //如果凭据的过期时间小于当前时间，说明过期了
            return false
          } */

      return data.expires_in > Date.now();

  }

  /**
   * 用来获取没有过期的ticket
   * @return {Promise<any>} ticket
   */
  fetchTicket () {
    //优化
    if (this.ticket && this.ticket_expires_in && this.isValidTicket(this)) {
      //说明之前保存过ticket，并且它是有效的, 直接使用
      return Promise.resolve({
        ticket: this.ticket,
        expires_in: this.ticket_expires_in
      })
    }
    
    return this.readTicket()
      .then(async res => {
        //本地有文件
        //判断它是否过期
        if (this.isValidTicket(res)) {
          //有效的
          return Promise.resolve(res);
        } else {
          //过期了
          const res = await this.getTicket();
          await this.saveTicket(res);
          return Promise.resolve(res);
        }
      })
      .catch(async err => {
        //本地没有文件
        const res = await this.getTicket();
        await this.saveTicket(res);
        return Promise.resolve(res);
      })
      .then(res => {
        //将ticket挂载到this上
        this.ticket = res.ticket;
        this.ticket_expires_in = res.expires_in;
        //返回res包装了一层promise对象（此对象为成功的状态）
        return Promise.resolve(res);
      })
  }

   
```

## 6、后台 JSSDK使用接口签名

### 微信封装的后台 接口签名sign



```javascript
var createNonceStr = function () {
  return Math.random().toString(36).substr(2, 15);
};

var createTimestamp = function () {
  return parseInt(new Date().getTime() / 1000) + '';
};

var raw = function (args) {
  var keys = Object.keys(args);
  keys = keys.sort()
  var newArgs = {};
  keys.forEach(function (key) {
    newArgs[key.toLowerCase()] = args[key];
  });

  var string = '';
  for (var k in newArgs) {
    string += '&' + k + '=' + newArgs[k];
  }
  string = string.substr(1);
  return string;
};

/**
* @synopsis 签名算法 
*
* @param jsapi_ticket 用于签名的 jsapi_ticket
* @param url 用于签名的 url ，注意必须动态获取，不能 hardcode
*
* @returns
*/
var sign = function (jsapi_ticket, url) {
  var ret = {
    jsapi_ticket: jsapi_ticket,
    nonceStr: createNonceStr(),
    timestamp: createTimestamp(),
    url: url
  };
  var string = raw(ret);
      sha1 = require('sha1');
      shaObj = sha1(string);
  ret.signature = shaObj;

  return ret;
};

module.exports = sign;

```

+ 使用微信`sign.js `接口签名

  

  ```javascript
  var sign = require('./sign.js');
  
  console.log(sign('jsapi_ticket', 'http://example.com'));
  /*
   *something like this
   *{
   *  jsapi_ticket: 'jsapi_ticket',
   *  nonceStr: '82zklqj7ycoywrk',
   *  timestamp: '1415171822',
   *  url: 'http://example.com',
   *  signature: '1316ed92e0827786cfda3ae355f33760c4f70c1f'
   *}
   */
  ```

  + 具体实现：

```javascript
const express = require('express');
const auth = require('./wechat/auth');
const Wechat = require('./wechat/wechat');
const {url,appId} = require('./config').wechat;
const sha1 = require('sha1');
var sign = require('./sign/sign');


const app = express();

app.set('views', 'views');
app.set('view engine', 'ejs');

const wechatApi = new Wechat();

app.get('/search', async (req, res,next) => {
  //用户访问微信中的网页触发的路由
  /*
    验证的签名算法
      1. 参与签名的字段包括noncestr（随机字符串）, 有效的jsapi_ticket, timestamp（时间戳）, url（当前网页的URL，不包含#及其后面部分）
      2. 对所有待签名参数按照字段名的ASCII 码从小到大排序（字典序）后，
      3. 使用URL键值对的格式（即key1=value1&key2=value2…）拼接成字符串string1。这里需要注意的是所有参数名均为小写字符。
      4. 对string1作sha1加密，字段名和字段值都采用原始值，不进行URL 转义。
   */
  //获取ticket
  const {ticket} = await wechatApi.fetchTicket();

  sign=sign(ticket, url+'/search')
 
  console.log(sign)
  // appId=sign.appId
  signature=sign.signature
  noncestr=sign.nonceStr
  timestamp=sign.timestamp

  //将数据渲染到页面上
  res.render('movie', {
    appId,
    signature,
    noncestr,
    timestamp
  })
  
  // next();
  
}) 

//应用中间级，能够接受处理所有请求
app.use(auth());

app.listen(8888, err => {
  if (!err) console.log('服务器启动成功了~~~');
})
```

### 自己node的后台 接口签名

+   验证的签名算法

+ [**常见错误及解决方法**](https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html#66)
![invalid signature签名错误](https://raw.githubusercontent.com/Panssorcc/picee/master/images/node-%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7-invalid%20signature%E7%AD%BE%E5%90%8D%E9%94%99%E8%AF%AF_2019-09-16_11-13-20.png)

  > 1. 参与签名的字段包括noncestr（随机字符串）, 有效的jsapi_ticket, timestamp（时间戳）, url（当前网页的URL，不包含#及其后面部分）
  >
  > 2. 对所有待签名参数按照字段名的ASCII 码从小到大排序（字典序）后，
  >
  > 3. 使用URL键值对的格式（即key1=value1&key2=value2…）拼接成字符串string1。这里需要注意的是所有参数名均为小写字符。
  >
  > 4. 对string1作sha1加密，字段名和字段值都采用原始值，不进行URL 转义。
  >
  >       

```javascript
const express = require('express');
const auth = require('./wechat/auth');
const Wechat = require('./wechat/wechat');
const {appId} = require('./config').wechat;
const sha1 = require('sha1');
const app = express();

app.set('views', 'views');
app.set('view engine', 'ejs');

const wechatApi = new Wechat();

app.get('/search', async (req, res) => {
  var url=req.query.url1;
  console.log("前端encodeURIComponent："+url)
  url=decodeURIComponent(url)
  console.log("decodeURIComponent："+url)
  fal="";//标记ajax和ejs
  if(url=="undefined"){
  
    res.render('search',{
      fal:false
    })
  }else{
//用户访问微信中的网页触发的路由
  /*
    验证的签名算法
      1. 参与签名的字段包括noncestr（随机字符串）, 有效的jsapi_ticket, timestamp（时间戳）, url（当前网页的URL，不包含#及其后面部分）
      2. 对所有待签名参数按照字段名的ASCII 码从小到大排序（字典序）后，
      3. 使用URL键值对的格式（即key1=value1&key2=value2…）拼接成字符串string1。这里需要注意的是所有参数名均为小写字符。
      4. 对string1作sha1加密，字段名和字段值都采用原始值，不进行URL 转义。
   */
  //获取ticket
  const {ticket} = await wechatApi.fetchTicket();
  //获取随机字符串
  const noncestr = Math.random().toString().split('.')[1];
  //获取当前时间戳
  const timestamp = Date.now().toString().substr(0,10);
 
 

  //2. 按照key=value将其拼接在一起
  const params = [
    'jsapi_ticket=' + ticket,
    'noncestr=' + noncestr,
    'timestamp=' + timestamp,
    'url=' + url 
  ]

  // 3. 按照字典序排序，再使用'&'将四个参数拼接在一起
  const string = params.sort().join('&');

  // 4. sha1加密
  const signature = sha1(string);
  appid =appId;
 
  
  //将数据JSON发送到页面上
  var obj = {"result":{
      appid,
      signature,
      noncestr,
      timestamp
    }};
    res.json(obj);
  
   
  
  }
  
})

//应用中间级，能够接受处理所有请求
app.use(auth());

app.listen(8888, err => {
  if (!err) console.log('服务器启动成功了~~~');
})
```



## 7、前端页面JSSDK使用步骤

[JSSDK使用步骤](https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html)

### **7.1简介**

微信JS-SDK ( JavaScript Software Development Kit )是微信公众平台面向网页开发者提供的基于微信内的网页开发工具包。

### **7.2功能**

通过使用微信JS-SDK，网页开发者可借助微信高效地使用拍照、选图、语音、位置等手机系统的能力，同时可以直接使用微信分享、扫一扫、卡券、支付等微信特有的能力，为微信用户提供更优质的网页体验。

简单来说，使用JS-SDK我们可以引入外部网页。

```ejs
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport"
        content="width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no">
  <title>猜电影</title>
</head>
<body>
<h1>点击标题，开始录音翻译</h1>
<div id="director"></div>
<p id="title"></p>
<p id="year"></p>
<p id="poster"></p>
<!--用来实现功能的移动端库-->
<script src="http://zeptojs.com/zepto-docs.min.js"></script>
<!--需要调用JS接口，就必须引入此文件 -->
<script src="http://res.wx.qq.com/open/js/jweixin-1.2.0.js"></script>
<script>
  $(function () {
    //微信全局配置，注入配置信息
    wx.config({
      debug: false, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。
      appId: '<%= appid%>', // 必填，公众号的唯一标识
      timestamp: '<%= timestamp %>', // 必填，生成签名的时间戳
      nonceStr: '<%= noncestr %>', // 必填，生成签名的随机串
      signature: '<%= signature %>',// 必填，签名
      jsApiList: [
        'startRecord',
        'stopRecord',
        'onVoiceRecordEnd',
        'translateVoice',
        'onMenuShareTimeline',
        'onMenuShareAppMessage',
        'onMenuShareQQ',
        'onMenuShareWeibo',
        'onMenuShareQZone'
      ] // 必填，需要使用的JS接口列表，没填的JS接口不能使用
    })
    //config信息验证后会执行ready方法，所有微信接口都在ready函数中调用
    wx.ready(function(){
      //判断当前客户端版本是否支持指定JS接口，此处只举一个例子
      wx.checkJsApi({
        jsApiList: ['onVoiceRecordEnd'], // 需要检测的JS接口列表，所有JS接口列表见附录2,
        success: function(res) {
          // 以键值对的形式返回，可用的api值true，不可用为false
          // 如：{"checkResult":{"chooseImage":true},"errMsg":"checkJsApi:ok"}
          console.log(res)
        }
      })

      const isRecording = false

      $('h1').on('tap', function () {
        if (!isRecording) {
          isRecording = true
          //开始录音
          wx.startRecord({
            cancel: function () {
              window.alert('您取消了音频录制，需要打开此功能')
            }
          })
          return
        }
        isRecording = false
        //停止录音
        wx.stopRecord({
          success: function (res) {
            const localId = res.localId
            //识别音频并返回识别结果
            wx.translateVoice({
              localId: localId,
              isShowProgressTips: 1, // 默认为1，显示进度提示
              success: function (res) {
                //识别后的结果，文本字符串
                const result = res.translateResult
                //根据结果请求豆瓣电影查询API
                $.getJSON('https://api.douban.com/v2/movie/search?q=' + result + '&callback=?', function (data) {
                  console.log(data)
                  const subjects = data.subjects[0]
                  console.log(subjects)
                  //将请求后返回的结果内容显示到页面上去
                  $('#director').html(subjects.directors[0].name)
                  $('#title').html(subjects.title)
                  $('#year').html(subjects.year)
                  $('#poster').html('<img src="' + subjects.images.large + '" />')
                  //添加一个分享给朋友接口
                  wx.onMenuShareAppMessage({
                    title: subjects.title, // 分享标题
                    desc: '我搜出来了' + subjects.title, // 分享描述
                    link: 'http://079e92c1.ngrok.io/share', // 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致
                    imgUrl: subjects.images.large, // 分享图标
                    type: 'link', // 分享类型,music、video或link，不填默认为link
                    dataUrl: '', // 如果type是music或video，则要提供数据链接，默认为空
                    success: function () {
                      // 用户确认分享后执行的回调函数
                      alert('分享成功')
                    },
                    cancel: function () {
                      // 用户取消分享后执行的回调函数
                      alert('分享失败')
                    }
                  })
                })
                alert(res.translateResult); // 语音识别的结果
              }
            })
          }
        })
      })
    })
  })
</script>
</body>
</html>
```



#### 分享功能模块

```javascript
 wx.onMenuShareAppMessage({
                    title: "分享标题", // 分享标题
                    desc: '我搜出来了', // 分享描述
                    link: 'http://1afc88ec.ngrok.io/personal_information.html', // 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致
                    imgUrl: 'https://raw.githubusercontent.com/Panssorcc/picee/master/blog/home_bg_pcc.jpg', // 分享图标
                    type: 'link', // 分享类型,music、video或link，不填默认为link
                    dataUrl: '', // 如果type是music或video，则要提供数据链接，默认为空
                    success: function () {
                      // 用户确认分享后执行的回调函数
                      alert('分享成功')
                    },
                    cancel: function () {
                      // 用户取消分享后执行的回调函数
                      alert('分享失败')
                    }
                  })
```



## 8、实战

### [puppeteer爬虫](https://github.com/GoogleChrome/puppeteer)

> phantomjs和puppeteer区别

+ 使用步骤

```javascript
const puppeteer = require('puppeteer');

(async () => {
  const browser = await puppeteer.launch(); //1. 打开浏览器
  const page = await browser.newPage();//2. 创建tab标签页
  await page.goto('https://example.com');//3. 跳转到指定网址
  await page.screenshot({path: 'example.png'});//4. 等待网址加载完成，开始爬取数据

  await browser.close(); //5. 关闭浏览器
})();
```

+  `let result = await page.evaluate(() => {})   `                   //对加载好的页面进行dom操作

     如果传递给`page.evaluate`返回值的函数返回[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)，`page.evaluate`则将等待promise解析并返回其值。

  

+ 开启延时器，延时2秒钟

```javascript
function timeout() {
  return new Promise(resolve => setTimeout(resolve, 2000))
}

//3 秒（3000 毫秒）后弹出 "Hello"
//setTimeout(function(){ alert("Hello"); }, 3000);
```

+ jQuery一个新方法`.data`

  - 比如有一个版本模块，版本标签为 1.0。
        `<div class="version" data-tag="1.0"></div>`
  -  采用 data() 方法，我们希望获取到的是版本标签值为 1.0。
        `var version_tag = $('.version').data('tag') // 该表达式获取的值为 1，而非 1.0`



+ 爬豆瓣

  ```javascript
  const puppeteer = require('puppeteer');
  
  //爬取热门电影信息
  const url = 'https://movie.douban.com/cinema/nowplaying/beijing/';
  
  
  module.exports = async () => {
    //1. 打开浏览器
    const browser = await puppeteer.launch({
      args: ['--no-sandbox'],
      //  headless: false    //以无头浏览器的形式打开浏览器，没有界面显示，在后台运行的
    });
    //2. 创建tab标签页
    const page = await browser.newPage();
    //3. 跳转到指定网址
    await page.goto(url, {
      waitUntil: 'networkidle2'  //等待网络空闲时，在跳转加载页面
    });
    //4. 等待网址加载完成，开始爬取数据
    //开启延时器，延时2秒钟在开始爬取数据
    await timeout();
    
    let result = await page.evaluate(() => {
      //对加载好的页面进行dom操作
      //所有爬取的数据数组
      let result = [];
      //获取所有热门电影的li
      const $list = $('#nowplaying>.mod-bd>.lists>.list-item');
      console.log($list)
      //只取8条数据
      for (let i = 0; i < 8; i++) {
        const liDom = $list[i];
        //电影标题
        let title = $(liDom).data('title');
        //电影评分
        let rating = $(liDom).data('score');
        //电影片长
        let runtime = $(liDom).data('duration');
        //导演
        let directors = $(liDom).data('director');
        //主演
        let casts = $(liDom).data('actors');
        //豆瓣id
        let doubanId = $(liDom).data('subject');
        //电影的详情页网址
        let href = $(liDom).find('.poster>a').attr('href');
        //电影海报图
        let image = $(liDom).find('.poster>a>img').attr('src');
        
        
        result.push({
          title,
          rating,
          runtime,
          directors,
          casts,
          href,
          image,
          doubanId
        })
      }
      
      //将爬取的数据返回出去
      return result;
    })
    
    console.log(result);
    
     //遍历爬取到的8条数据
    for (let i = 0; i < result.length; i++) {
      //获取条目信息
      let item = result[i];
      //获取电影详情页面的网址
      let url = item.href;
      
      //跳转到电影详情页(url是进去新链接)
      await page.goto(url, {
        waitUntil: 'networkidle2'  //等待网络空闲时，在跳转加载页面
      });
    
      //爬取其他数据
      let itemResult = await page.evaluate(() => {
        let genre = [];
        //类型
        const $genre = $('[property="v:genre"]');
    
        for (let j = 0; j < $genre.length; j++) {
          genre.push($genre[j].innerText);
        }
        
        //简介
        const summary = $('[property="v:summary"]').html().replace(/\s+/g, '');
        
        //上映日期
        const releaseDate = $('[property="v:initialReleaseDate"]')[0].innerText;
        
        //给单个对象添加两个属性
        return {
          genre,
          summary,
          releaseDate
        }
        
      })
    
      // console.log(itemResult);
      //在最后给当前对象添加三个属性
      //在evaluate函数中没办法读取到服务器中的变量
      item.genre = itemResult.genre;
      item.summary = itemResult.summary;
      item.releaseDate = itemResult.releaseDate;
      
    }
    
    console.log(result);
    
    //5. 关闭浏览器
    await browser.close();
    
    //最终会将数据全部返回出去
    return result;
  }
  
  function timeout() {
    return new Promise(resolve => setTimeout(resolve, 2000))
  }
  ```

  

+ 使用方法（爬到的内容）

```javascript
const tc=require('./crewler/theatersCrawler');

(async ()=>{
 await tc();
})()
```

### 将数据存储（mongoose）

#### 1、连接数据库模块

+ `db/index.js`

```javascript
//引入mongoose
const mongoose = require('mongoose');

module.exports = new Promise((resolve, reject) => {
  //连接数据库
  mongoose.connect('mongodb://203.195.242.11:27017/pcc_movie', {useNewUrlParser: true});
  //绑定事件监听
  mongoose.connection.once('open', err => {
    if (!err) {
      console.log('数据库连接成功了~~');
      resolve();
    } else {
      reject('数据库连接失败：' + err);
    }
  })
})
```

#### 2、创建对象 和 保存数据模块

##### 2.1 创建集合和数据结构

+ `model/theaters.js`

  ```javascript
  //引入mongoose
  const mongoose = require('mongoose');
  //获取Schema
  const Schema = mongoose.Schema;
  //创建约束对象
  const theatersSchema = new Schema({
    title: String,
    rating: Number,
    runtime: String,
    directors: String,
    casts: String,
    image: String,
    doubanId: {
      type: Number,
      unique: true
    },
    genre: [String],
    summary: String,
    releaseDate: String,
    posterKey: String,     //图片上传到七牛中，返回的key值
    createTime: {
      type: Date,
      default: Date.now()
    }
  })
  //创建模型对象
  const Theaters = mongoose.model('Theaters', theatersSchema);
  //暴露出去
  module.exports = Theaters;
  ```

  

##### 2.2保存数据模块

+ `server/save/saveTheaters.js`

```javascript
//引入Theaters
const Theaters = require('../../model/Theaters');

module.exports = async data => {
  
  for (var i = 0; i < data.length; i++) {
    let item = data[i];
  
   const res= await Theaters.create({
      title: item.title,
      rating: item.rating,
      runtime: item.runtime,
      directors: item.directors,
      casts: item.casts,
      image: item.image,
      doubanId: item.doubanId,
      genre: item.genre,
      summary: item.summary,
      releaseDate: item.releaseDate,
    })
  
    console.log('数据保存成功');
    console.log(res);
    
  }
  
}
```

#### 3、具体使用Mongoose保存

```javascript
const db=require('../db');
const theatersCrawler=require('./crewler/theatersCrawler');
const saveTheaters=require('./save/saveTheaters');

(async ()=>{
    //连接数据库
    await db;
    //爬取数据
    const data=await theatersCrawler();
    //保存数据
    await saveTheaters(data)

})()
```

### 从数据库获取数据并渲染

> ##### 网页使用外链图片403无法显示问题
> 用了最简单方式，屏蔽自己网站的Referrer，在head标签内添加如下mata标签：
>
> ```HTML
>  <meta name="referrer" content="no-referrer" />
> ```
>



### 豆瓣API

+ **电影详情**

  接口：https://api.douban.com/v2/movie/subject/:id

  访问参数：电影id

  如：电影《中国机长》的电影id为：30295905，搜索此电影的详细信息：

`https://api.douban.com/v2/movie/subject/30295905?apikey=0df993c66c0c636e29ecbb5344252a4a`

+ 电影搜索

  `https://api.douban.com/v2/movie/search?q=双子杀手&count=8&apikey=0df993c66c0c636e29ecbb5344252a4a`





### 上传图片、视频到七牛中

+ `qiniu/upload.js`文件

```javascript
//引入qiniu模块
const qiniu = require('qiniu');

const accessKey = '*************';
const secretKey =  '*************';
//定义鉴权对象
const mac = new qiniu.auth.digest.Mac(accessKey, secretKey);

/* 公开空间，其访问的链接主要是将空间绑定的域名（可以是七牛空间的默认域名或者是绑定的自定义域名）拼接上空间里面的文件名即可访问*/


//定义配置对象
const config = new qiniu.conf.Config();
//存储区域   z1  -- 华北
config.zone = qiniu.zone.Zone_z0;
//bucketManager对象上就有所有的方法
const bucketManager = new qiniu.rs.BucketManager(mac, config);
// 存储空间的名称
const bucket = '201910movie';

module.exports = (resUrl, key) => {
  /*
    resUrl  网络资源的地址
    bucket  存储空间的名称 students
    key     重命名网络资源的名称
   */
  return new Promise((resolve, reject) => {
  

    bucketManager.fetch(resUrl, bucket, key, function (err, respBody, respInfo) {
     
      if (err) {
        reject('上传七牛方法出了问题' + err);
      } else {
        if (respInfo.statusCode == 200) {
          console.log('文件上传成功');
          resolve();
        }
      }
    });
  })
}
```

+ `qiniu/index.js`文件

  ```javascript
  /*
    将数据库中的图片上传到七牛云服务器中
   */
  //上传图片到七牛中方法
  const upload = require('./upload');
  //生成唯一的key方法
  const nanoid = require('nanoid');
  
  module.exports = async (key, Model) => {
    /*
      1. 获取数据库中的图片链接
      2. 上传到七牛中
      3. 保存key到数据库中
     */
    //去数据库中找所有没有上传图片的文档对象
    // const movies = await Model.find({posterKey: {$in: ['', null, {$exists: false}]}});
    const movies = await Model.find({$or: [
        {[key]: ''},
        {[key]: null},
        {[key]: {$exists: false}}
      ]});
    
    //遍历每一条数据
    for (let i = 0; i < movies.length; i++) {
      //获取每一个文档对象
      let movie = movies[i];
     
      //初始化两个值
      let url = movie.image;
      let filename = '.jpg';
      //上传图片到七牛
      if (key === 'coverKey') {
        url = movie.cover;
      } else if (key === 'videoKey') {
        url = movie.link;
        filename = '.mp4';
      }
    
      //文件名
      filename = `${nanoid(10)}${filename}`;
   
      await upload(url, filename);
      
      //保存key到数据库中
      movie[key] = filename;
    
      await movie.save();
      
    }
    
    
    
    
  }
  ```

  

  

### [DPlayer插件](http://dplayer.js.org/guide.html#quick-start)

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/dplayer/1.24.0/DPlayer.min.css" rel="stylesheet">
    <title>Document</title>
</head>

<body>
    <div id="dplayer"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dplayer/1.24.0/DPlayer.min.js"></script>
    <script>
        const dp = new DPlayer({
            container: document.getElementById('dplayer'),
            video: {
                url: 'http://pzimmv55m.bkt.clouddn.com/GBqAJw1aPG.mp4',
            },
        });

    </script>

</body>

</html>
```

